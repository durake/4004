#include "xmpp.h"
#include "DealXmppData.h"
#include "middleware.h"

#define 	NS_INADDRSZ     4
#define PSEUDO_HOST_STACK_SIZE_6K (6 * 1024 )
#define RECV_SERV_BUF_SIZE (1024*3)
#define N 7//固定长度为7
#define BYTE_POOL_SIZE_6K (6*1024 + 256 )

static uint8_t connect_err_count = 0;

TX_BYTE_POOL pool3;
TX_THREAD xmppRecvTid;

//ghy add
char gxmppUserName[64] = { 0 };
char gxmppPassWd[64] = { 0 };

static uint32_t addr_ip4 = 0;

char gxmppServIP[64] = { 0 };
short gxmppServPort = 0;

char ghttpServIP[64] = { 0 };
short ghttpServPort = 0;
char ghttpUserID[20] = { 0 };

int gHttpIsInited = 1;

static int gServLiveTime = 0;

int gServConnected = 0;/*-1:error,0:disconnect,1:connect */
int gServSock = -1;
int gIsInited = 1;
int gStatus = 0; //used for add and delete friends
int gDelStatus = 0;
extern CH_MSGS_IReceiver_t_CB gCH_MSGS_IReceiver_t_CB;
extern CH_MSGS_IConnection_t_CB gCH_MSGS_IConnection_t_CB ;

int get_ip_addr_from_string(const char *string);

static unsigned int get_ip4(char *host) {

	uint32_t ipAddress;
	struct sockaddr_in addr4;

	memset(&addr4, 0, sizeof(struct sockaddr_in));
	if (1 == inet_pton(AF_INET, host, &(addr4.sin_addr))) {
		A_PRINTF("addr4.sin_addr.s_addr = %lu\r\n", addr4.sin_addr.s_addr);
		return (addr4.sin_addr.s_addr);
	}

	if (qcom_dnsc_get_host_by_name(host, &ipAddress) != A_OK) {
		A_PRINTF("ipAddress = 0\r\n");
		ipAddress = 0;
	}
	A_PRINTF("ipAddress = %u\r\n", ipAddress);
	return (ipAddress);

}

static int xmpp_parse_ip_addr_from_string(const char *string, char *ip, short *port) {
	/*
	 char *p = NULL;
	 struct in_addr addr;
	 char str_tmp[256] = { 0 };
	 //"10.3.93.241:5222";
	 if (string == NULL || ip == NULL)
	 return -1;
	 p = strchr(string, ':');
	 *port = atoi(p + 1);
	 memcpy(str_tmp, string, p - string);
	 addr.s_addr = get_ip4(str_tmp);
	 if (addr.s_addr == 0) {
	 return -1;
	 }

	 char* ipstr = inet_ntoa(addr);
	 strcpy(ip, ipstr);
	 printf("ip=%s,port=%d\n", ip, *port);*/
	return 0;
}

int parse_ip_addr_from_string(const char *string, char *ip, short *port) {
	/*
	 char *p = NULL;
	 struct in_addr addr;
	 char str_tmp[256] = { 0 };
	 //"10.3.93.241:5222";
	 if (string == NULL || ip == NULL)
	 return -1;
	 p = strchr(string, ':');
	 *port = atoi(p + 1);
	 memcpy(str_tmp, string, p - string);
	 addr.s_addr = get_ip4(str_tmp);
	 if (addr.s_addr == 0) {
	 return -1;
	 }

	 char* ipstr = inet_ntoa(addr);
	 strcpy(ip, ipstr);
	 printf("ip=%s,port=%d\n", ip, *port);*/

	return 0;
}



int InitInfoToServer() {

	return 0;
}

void server_thread() {
	int ret = 0;
	int recv_len = 0;
	int left_len = 0;
	char* recv_buf = NULL;

	struct timeval tv;
	q_fd_set fd_read;
	gServConnected = -1;

	struct sockaddr_in serv_addr;

	recv_buf = (char*) mem_alloc(RECV_SERV_BUF_SIZE);
	memset(recv_buf, 0, RECV_SERV_BUF_SIZE);

	start: recv_len = 0;
	left_len = 0;
	memset(recv_buf, 0, RECV_SERV_BUF_SIZE);

	gServSock = qcom_socket(AF_INET, SOCK_STREAM, 0);
	if (gServSock < 0) {
		A_PRINTF("err:socket():%s:%d\n", __func__, __LINE__);
		qcom_socket_close(gServSock);
		goto start;
	}

	set_socket_timeout(gServSock, 30);/*30s*/

	serv_addr.sin_family = AF_INET;
	get_ip_addr_from_string(gxmppServIP);

	A_PRINTF("addr_ip4:0x%08x  port:%d\n", addr_ip4, gxmppServPort);
	serv_addr.sin_addr.s_addr = htonl(addr_ip4); // inet_addr
	serv_addr.sin_port = htons(gxmppServPort);

	A_PRINTF("socket:%d %s:%d\n", gServSock, __func__, __LINE__);
	ret = qcom_connect(gServSock, (struct sockaddr *) &serv_addr,
			sizeof(serv_addr));
//	A_PRINTF("ret:%d\n", ret);

	connect_err_count++;
	if (ret < 0 && connect_err_count > 20) {

		A_PRINTF("Can't connect xmpp server !!!\r\n");
		goto end;

	}
	if (ret == -1) {
		gServConnected = -1;
		qcom_thread_msleep(1 * 1000);
		qcom_socket_close(gServSock);
		goto start;
	} else if (ret == 0) {
		gServConnected = 1;

		gCH_MSGS_IConnection_t_CB(CONSTATE_CONNECT);
		connect_err_count = 0;
		gServLiveTime = get_current_time();
	}

	FD_ZERO(&fd_read);
	FD_SET(gServSock, &fd_read);

	tv.tv_sec = 10;
	tv.tv_usec = 0;
	while (gIsInited == 1) {
		FD_SET(gServSock, &fd_read);

		/*the argument is a must, or select() will error*/
		tv.tv_sec = 10;
		tv.tv_usec = 0;

		ret = qcom_select(gServSock + 1, &fd_read, NULL, NULL, &tv);
		if (ret < 0) {
			A_PRINTF("err: select() fail\n");

			continue;
		} else if (ret > 0) { /*something can be read*/

			if (FD_ISSET(gServSock, &fd_read)) {

				recv_len = qcom_recv(gServSock, recv_buf + left_len,
						RECV_SERV_BUF_SIZE - left_len, 0);

				if (recv_len > 0) {
					//	A_PRINTF("p=######leftLen:%d ::  %s  ######\n", left_len,
					//		recv_buf);
					A_PRINTF("---------\n recv_len:%d-------\n", recv_len);
					gServLiveTime = get_current_time();
					left_len = handlexmpp(recv_buf, left_len + recv_len);

				}

				else if (recv_len == 0) {
					gServConnected = -1;
					A_PRINTF("info: recv_len = 0 ,network is cut off:%s:%d\n",
							__func__, __LINE__);
//TODO
					gCH_MSGS_IConnection_t_CB(CONSTATE_CONNECT_ERROR);
				}

				else {/*recv_len<0*/

//					if (errno == EINTR || errno == EWOULDBLOCK
//							|| errno == EAGAIN) {
//						A_PRINTF(
//								"info: recv() encounter with some problem:%s:%d\n",
//								__func__, __LINE__);
//					} else {
//						gServConnected = -1;
					A_PRINTF("info: network is cut off:%s:%d\n", __func__,
							__LINE__);

					gServConnected = -1;
					//gCH_MSGS_IConnection_t_CB(2);
					gCH_MSGS_IConnection_t_CB(CONSTATE_CONNECT_ERROR);

//					}

				}
			}

		} else {/*select() time out*/
			A_PRINTF("select timeout...\n");
			sendHeart();

		}

		if (gServConnected == -1) {/*network is been cut off, try to connect again*/
			qcom_socket_close(gServSock);
			A_PRINTF("\nnetwork is been cut off,connect fail");
			qcom_thread_msleep(30 * 1000);
			goto start;
		}

	}

	end: if (recv_buf != NULL)
		mem_free(recv_buf);
	qcom_socket_close(gServSock);

	gServConnected = 0;
	gCH_MSGS_IConnection_t_CB(CONSTATE_DISCONNECT);
	gServSock = -1;
	A_PRINTF("info: server_thread exit\n");

}

int init(char* userId, char* http_ip, int http_port) {
//	char* xmppPassWd = "@776#059";
	char* xmppPassWd = "6@#12591";
	strcpy(gxmppPassWd, xmppPassWd);
	strcpy(ghttpServIP, http_ip);
	ghttpServPort = http_port;
	strcpy(ghttpUserID, userId);

	int ret = getXmppAddr(userId, http_ip, http_port);
	if (ret < 0) {
		A_PRINTF("get xmppserver ip port error\n");
		return ret;
	}

	tx_byte_pool_create(&pool3, "xmpp recv", TX_POOL_CREATE_DYNAMIC,
			BYTE_POOL_SIZE_6K);
	{
		CHAR *pointer;
		tx_byte_allocate(&pool3, (VOID **) &pointer, PSEUDO_HOST_STACK_SIZE_6K,
				TX_NO_WAIT);
		tx_thread_create(&xmppRecvTid, "xmpp recv thread", server_thread, 0,
				pointer, PSEUDO_HOST_STACK_SIZE_6K, 16, 16, 4, TX_AUTO_START);
	}

	return ret;

}

int inet_pton(int af, const char *src, void *dst) {
	switch (af) {
	case AF_INET:
		return (inet_pton4(src, dst));
	default:
		return 0;
	}
	/* NOTREACHED */
} // end inet_pton

static int set_socket_timeout(int fd, int time) {
	int32_t ret = -1;
	struct timeval timeout;

	if (fd < 0 || time < 0) {
		return (-1);
	}

	timeout.tv_sec = time;
	timeout.tv_usec = 0;

	ret = qcom_setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &timeout,
			sizeof(timeout));
	if (ret < 0) {
		A_PRINTF("---%s---%d---", __FUNCTION__, __LINE__);
		qcom_socket_close(fd);
		return (-1);
	}
	return 0;
}

long get_current_time() {
	struct timeval time;
	// time.tv_sec = GetCurrentTime();
	return time.tv_sec;
}

int inet_pton4(src, dst)
	const char *src;unsigned char *dst; {
	static const char digits[] = "0123456789";
	int saw_digit, octets, ch;
	unsigned char tmp[NS_INADDRSZ], *tp;

	saw_digit = 0;
	octets = 0;
	*(tp = tmp) = 0;
	while ((ch = *src++) != '\0') {
		const char *pch;

		if ((pch = strchr(digits, ch)) != NULL) {
			unsigned int new = *tp * 10 + (pch - digits);

			if (new > 255)
				return (0);
			*tp = new;
			if (!saw_digit) {
				if (++octets > 4)
					return (0);
				saw_digit = 1;
			}
		} else if (ch == '.' && saw_digit) {
			if (octets == 4)
				return (0);
			*++tp = 0;
			saw_digit = 0;
		} else
			return (0);
	}
	if (octets < 4)
		return (0);
	memcpy(dst, tmp, NS_INADDRSZ);
	return (1);
} // end inet_pton4

//addr_ip4
int get_ip_addr_from_string(const char *string) {

	struct in_addr addr;
	char str_tmp[256] = { 0 };

	memcpy(str_tmp, string, strlen(string));
	addr.s_addr = get_ip4(str_tmp);
	A_PRINTF("addr.s_addr =0x %08x\r\n", addr.s_addr);
	if (addr.s_addr == 0) {
		return -1;
	}

//	addr_ip4 = addr.s_addr;
	char i4 = addr.s_addr >> 24 & 0xFF;
	char i3 = addr.s_addr >> 16 & 0xFF;
	char i2 = addr.s_addr >> 8 & 0xFF;
	char i1 = addr.s_addr & 0xFF;
//  j = (i1<<24)|(i2<<16)|(i3<<8)|i4;

	addr_ip4 = (i1 << 24) | (i2 << 16) | (i3 << 8) | i4; //by lm

	return 0;
}

int sendHeart() {
	char* send_buf = "<p/>";

	int bufLen = 0;
	bufLen = strlen(send_buf);
	int ret = -1;

	if (gServSock != -1 && gServConnected == 1) {/*send the data*/

		A_PRINTF("====== %s\n", send_buf);
		qcom_send(gServSock, send_buf, bufLen, 0);

		ret = 0;
	} else {

		ret = -1;
	}

}

int handlexmpp(char* xmpp, int xmpplen) {

	char* xmlheadptr = NULL;
	int DelLen = 0;
	int leftDataLen = 0;

	xmlheadptr = strstr(xmpp, "<?xml");

	if (xmlheadptr != NULL) {

		DelLen = dealXmppHead(xmlheadptr);
		memcpy(xmlheadptr, xmlheadptr + DelLen,
				xmpplen - DelLen - (xmlheadptr - xmpp));
		memset(xmlheadptr + xmpplen - DelLen - (xmlheadptr - xmpp), 0, DelLen);
		leftDataLen = xmpplen - DelLen;

	}

	DelLen = 0;
//	printf("%s:%d \n", __func__, __LINE__);
	//find success register respose
	char* regResponse = NULL;

	regResponse = strstr(xmpp, "<success xmlns=");
	if (regResponse != NULL) {
//deal success
		DelLen = dealsuccess(regResponse);

		memcpy(regResponse, regResponse + DelLen,
				xmpplen - DelLen - (regResponse - xmpp));
		memset(regResponse + xmpplen - DelLen - (regResponse - xmpp), 0,
				DelLen);
		leftDataLen = xmpplen - DelLen;

	}

	char* requestResponse = NULL;

	requestResponse = strstr(xmpp, "<iq");
	if (requestResponse != NULL) {
//deal success
		DelLen = dealrequestResponse(requestResponse);

		memcpy(requestResponse, requestResponse + DelLen,
				xmpplen - DelLen - (requestResponse - xmpp));
		memset(requestResponse + xmpplen - DelLen - (requestResponse - xmpp), 0,
				DelLen);
		leftDataLen = xmpplen - DelLen;
	}

	char* presencePtr = NULL;

	presencePtr = strstr(xmpp, "<presence");
	if (presencePtr != NULL) {
		//deal presence
		DelLen = dealpresence(presencePtr);

		memcpy(presencePtr, presencePtr + DelLen,
				xmpplen - DelLen - (presencePtr - xmpp));
		memset(presencePtr + xmpplen - DelLen - (presencePtr - xmpp), 0,
				DelLen);
		leftDataLen = xmpplen - DelLen;

	}

	char* messagePtrStart = NULL;
	char* messagePtrEnd = NULL;
	messagePtrStart = strstr(xmpp, "<message");
	messagePtrEnd = strstr(xmpp, "</message>");
	int tempLen = xmpplen;

	while ((messagePtrStart != NULL) && (messagePtrEnd != NULL)) {
		//deal message

		DelLen = dealmessage(messagePtrStart);

		memcpy(messagePtrStart, messagePtrStart + DelLen,
				xmpplen - DelLen - (messagePtrStart - xmpp));
		memset(messagePtrStart + xmpplen - DelLen - (messagePtrStart - xmpp), 0,
				DelLen);
		leftDataLen = tempLen - DelLen;
		tempLen = leftDataLen;
		//messagePtrStart = strstr(xmpp, "<message");
		messagePtrStart = NULL;
		messagePtrEnd = NULL;
		//	printf("*********************** %s \n",xmpp);
		messagePtrStart = strstr(xmpp, "<message");
		messagePtrEnd = strstr(xmpp, "</message>");

	}

	return leftDataLen;

}

